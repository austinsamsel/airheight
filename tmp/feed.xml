<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog Name</title>
  <subtitle>Blog subtitle</subtitle>
  <id>http://blog.url.com/blog</id>
  <link href="http://blog.url.com/blog"/>
  <link href="http://blog.url.com/feed.xml" rel="self"/>
  <updated>2015-12-03T14:04:00-05:00</updated>
  <author>
    <name>Blog Author</name>
  </author>
  <entry>
    <title>Working with a React View Layer in Meteor</title>
    <link rel="alternate" href="http://blog.url.com/blog/working-with-react-in-meteor.html"/>
    <id>http://blog.url.com/blog/working-with-react-in-meteor.html</id>
    <published>2015-12-03T14:04:00-05:00</published>
    <updated>2015-12-03T14:33:35-05:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h1&gt;Integrating a React View Layer in Meteor&lt;/h1&gt;

&lt;p&gt;I've been trying to stay focused in terms of what new technologies I'll try out or learn. I've been reading about React since the beginning of the year, but I've held off on doing anything more than a tutorial. Now it seems like &lt;a href="https://forums.meteor.com/t/next-steps-on-blaze-and-the-view-layer/13561"&gt;React might be more fully integrated with Meteor&lt;/a&gt; as a front end engine, beyond official support by the Meteor Development Group. According to the discussion its possible Blaze 2.0 could be some kind of merger with React. Once I read that, it gave me the excuse I needed to start working with React.&lt;/p&gt;

&lt;h2&gt;Still &amp;lt;3 you Blaze&lt;/h2&gt;

&lt;p&gt;Blaze made development really fast and productive. Wrapping HTML in template tags felt like a pretty good separation of concerns and was really easy to conceptualize. I had my HTML, my CSS, and my Javascript. If I needed some logic in my templates I had a lot of options with spacebars, helpers. However, it seems like we can get all that same functionality with React.&lt;/p&gt;

&lt;h2&gt;Cleaner Code&lt;/h2&gt;

&lt;p&gt;To test it out, I'm creating an app that lets users send letters (or messages), snail mail style — where it takes a few days for each message to be delivered. It's an idea I've been thinking about for a while.&lt;/p&gt;

&lt;p&gt;By now I've run the &lt;a href="https://www.meteor.com/tutorials/react/creating-an-app"&gt;official Meteor React tutorial&lt;/a&gt; a couple times and used that basic functionality as a starting point for this app. I feel like I finally hit that react style "functional" (using this word lightly here) programming moment when I refactored a bunch of functionality I was storing in variables... and moved it out into functions which could be used a little bit more open-endedly and repeatedly. Of course you don't need React to code like this, but this style is more encouraged... As a reference for the following example, you can see the full code at my &lt;a href="https://github.com/austinsamsel/snail"&gt;Github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In my user.jsx file, my code was looking like this. This is probably how I would have written my apps in Meteor before. I'd use a lot of variables and make it kind of human readable by naming them well. It always worked! But there's probably a better way…&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// components/User.jsx
render(){
  var currentUserId = Meteor.userId();
  var followedUserId = this.props.user._id;
  var notCurrentUser = this.props.user._id != currentUserId;
  var notFollowedByCurrentUser = Relationships.findOne({$and : [{owner : currentUserId}, {saveContact : followedUserId}] }) == null;
  var followUserButton = notCurrentUser &amp;&amp; notFollowedByCurrentUser;

  var followedByCurrentUser = Relationships.findOne({$and : [{owner : currentUserId}, {saveContact : followedUserId}] }) != null;

  var unfollowUserButton = notCurrentUser &amp;&amp; followedByCurrentUser;

return (
  &lt;li&gt;
    {this.props.user.username}
    { followUserButton ? (
      &lt;button className="save" onClick={this.saveThisContact}&gt;save contact&lt;/button&gt;
      ) : ''}

    { unfollowUserButton ? (
      &lt;button className="remove" onClick={this.removeThisContact}&gt;remove contact&lt;/button&gt;
    ): ''}
  &lt;/li&gt;
  )
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;I searched around for how other people were working with React, especially in terms of Meteor and came across &lt;a href="http://blog.differential.com/react-for-meteor-developers/"&gt;this article&lt;/a&gt; which inspired me to rearrange my code like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// components/User.jsx
render(){
  return (
    &lt;li&gt;
      {this.props.user.username}
      {this.followButton()}
      {this.unfollowButton()}
    &lt;/li&gt;
  )
},
//method calls
saveThisContact() {
  Meteor.call("saveContact", this.props.user._id);
},
removeThisContact(){
  var currentUserId = Meteor.userId();
  var followedUserId = this.props.user._id;
  Meteor.call("removeContact", currentUserId, followedUserId);
},
// render conditionals
followButton(){
  if ( ! this.isCurrentUser() &amp;&amp; ! this.isFollowed() ) {
    return &lt;button
      className="save"
      onClick={this.saveThisContact}&gt;
      save contact
    &lt;/button&gt;;
  }
},
unfollowButton(){
  if ( ! this.isCurrentUser() &amp;&amp; this.isFollowed() ) {
    return &lt;button
      className="remove"
      onClick={this.removeThisContact}&gt;
      remove contact
    &lt;/button&gt;;
  }
},
// helper functions
isCurrentUser(){
  if (this.props.user._id == Meteor.userId())
    return true;
},
isFollowed(){
  if (Relationships.findOne({$and: [{owner: Meteor.userId()}, {saveContact: this.props.user._id}] }) != null)
    return true;
},&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Here, I moved the render() function towards the top, so if I'm searching through my files, I'll immediately see what's being rendered in the UI, rather than a bunch of functions. I replaced all the variables with functions. I also moved the if/else logic out of the render() function and into helper functions. On the one hand, the first render() function looks a lot more clean, but also a lot more empty. This definitely spreads out the code more, but I think it'd also be faster to trace. And as the app grows, or if more is included in the component, it should be easy to maintain.&lt;/p&gt;

&lt;h2&gt;Atmosphere packages&lt;/h2&gt;

&lt;p&gt;It isn't explicitly said anywhere, so maybe this is just something that is obvious to everyone but me, but you can use atmosphere packages really easily with React in your Meteor projects. The Meteor-react tutorial gave some special care to the Accounts UI package, setting it up in a wrapper before placing it in the DOM. This got me thinking I'd need to drop Atmosphere and start working with meteorhacks:npm and cosmos:browserify packages.&lt;/p&gt;

&lt;p&gt;However, yes, you can use Atmosphere as your package manager. When I wanted to include a timestamp for each message, I ran "meteor add momentjs:moment" in the command line as usual to include &lt;a href="http://momentjs.com/"&gt;Moment&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I like to do things step by step, so I first tried to print the timestamp with a prop like:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;{this.props.letter.createdAt}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;so that I could at least see the object I'd be working with. However this returned a pretty dense error message:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Uncaught Error: Invariant Violation: Objects are not valid as a React child (found: Sun Nov 29 2015 17:31:47 GMT-0500 (EST)). If you meant to render a collection of children, use an array instead or wrap the object using createFragment(object) from the React add-ons. Check the render method of `Letter`.&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;After some googling I caught a hint that the date object needed to be converted to a string first.&lt;/p&gt;

&lt;p&gt;So I created a function to do just that&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;letterCreatedAt(){
  var a = this.props.letter.createdAt;
  return a.toString();
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;And added in a call from the render() function:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;{this.letterCreatedAt()}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Seeing that that worked. I updated my function to covert the timestamp with Moment JS.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;letterCreatedAt(){
  var a = this.props.letter.createdAt;
  return moment(a).format('MMMM Do YYYY, h:mm a');
}&lt;/code&gt;&lt;/pre&gt;


&lt;h2&gt;React packages&lt;/h2&gt;

&lt;p&gt;Some atmosphere packages won't work well with React. For example, I wanted to build an input field with autocomplete functionality that would help search for users. I began installing the &lt;a href="https://github.com/sergeyt/meteor-typeahead/"&gt;typeahead package&lt;/a&gt; which was based on meteor templates and found out it was not going to be easily compatible with React.&lt;/p&gt;

&lt;p&gt;So for a case like this I needed browserify and meteorhacks:npm as described in the &lt;a href="http://react-in-meteor.readthedocs.org/en/latest/client-npm/"&gt;React-in-Meteor docs&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I found the &lt;a href="https://github.com/elidoran/cosmos-browserify"&gt;cosmos:browserify&lt;/a&gt; docs contradicted the React-in-Meteor docs suggesting to use &lt;a href="https://www.npmjs.com/package/browserify-exposify"&gt;exposify&lt;/a&gt; rather than &lt;a href="https://www.npmjs.com/package/externalify"&gt;externalify&lt;/a&gt; in order to instruct any npm modules to use Meteor's version of react. The cosmos:browserify docs also suggested to place the browserify files in a client/lib folder so the libraries are only loaded once, instead of twice (client and server).&lt;/p&gt;

&lt;p&gt;Once following the instructions for set up I was able to get it working with &lt;a href="https://www.npmjs.com/package/react-typeahead"&gt;React Typeahead&lt;/a&gt;. I tried several different similar packages, but this was the easiest to get working.&lt;/p&gt;

&lt;h2&gt;Onward&lt;/h2&gt;

&lt;p&gt;At this point in my app, I've created the barebones functionality with the backend Meteor logic and simple react components to create views. I'm looking forward to animating with React and turning this into a full featured application.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Building Capote Meteor &amp; Mocha TDD (Part 5)</title>
    <link rel="alternate" href="http://blog.url.com/blog/building-capote-part-5.html"/>
    <id>http://blog.url.com/blog/building-capote-part-5.html</id>
    <published>2015-11-17T01:00:00-05:00</published>
    <updated>2015-12-03T14:31:02-05:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h1&gt;Building Capote: Meteor &amp;amp; Mocha TDD (Part 5)&lt;/h1&gt;

&lt;p&gt;In the last post we built our word count feature. In this part, we're going to create our daily goal feature. We'll be using the daily goal to compare with the word count. Once the user sets the daily goal then we can set a minimum word count for each post and prevent the user from submitting a post that doesn't have enough words.&lt;/p&gt;

&lt;p&gt;You can grab the code from the last chapter &lt;a href="https://github.com/austinsamsel/capote/tree/part-4"&gt;here&lt;/a&gt;. If you want to review the last post, you can &lt;a href="http://hightopsnyc.com/blog/building-capote-part-4.html"&gt;visit it here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Here's the test for our daily goal. I want to make sure I can see the goal in the DOM, and I also want the user to be able to change the goal and we'll see that goal's value in the database.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// tests/mocha/client/client.js

describe("change daily words goal", function(){
  after(function(done){
    $('[name="goal"]').val('');
    done();
  });
  it("user can change their goal", function(){
    Meteor.flush();
    $('[name="goal"]').val(2);
    chai.assert.equal($('[name="goal"]').val(), 2)
  });
});&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Let's create a new template for the daily goal.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// client/index.html
…

{{&amp;gt; createPost}}
{{&amp;gt; wordcount}}
{{&amp;gt; dailyGoal}} &amp;lt;!-- include the helper right below the word count --&amp;gt;

…
&amp;lt;template name="dailyGoal"&amp;gt;
  &amp;lt;div class="dailyGoal"&amp;gt;
    &amp;lt;form&amp;gt;
      Your daily goal: &amp;lt;input value="{{dailyGoal}}" placeholder="your goal" name="goal"&amp;gt; words.
   &amp;lt;/form&amp;gt;
 &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our test passes because it just checks the UI. Now we need to create a Goals collection so we can save the goal in our database as well.&lt;/p&gt;

&lt;p&gt;I'll add this test to our server tests:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;//tests/mocha/server/server.js

describe("save daily words goal in database", function(){
  before(function(done){
    var goalSaved = Goals.findOne()._id;
    Goals.update({_id: goalSaved}, {$set: {dailyGoal: 1}});
    done();
  });
  it("saves the goal in the database", function(){
    Meteor.flush();
    chai.assert(Goals.findOne().dailyGoal == 1);
  });
});&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;We'll also need a Goals publication and subscription. We'll take care of feeding our form the daily goal value with a helper. Finally, we'll structure the form to update our goal's value in the database on the keyup event, so that when the user edits their daily goal, it's automatically saved.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// model/goals.js
Goals = new Mongo.Collection('goals');

if (Meteor.isClient) {
  Meteor.subscribe('goals');

  Template.dailyGoal.helpers({
    dailyGoal: function() {
      var theGoal = Goals.findOne().dailyGoal;
      return theGoal
    }
  });

  Template.dailyGoal.events({
    'keyup [name=goal]': function(e){
      e.preventDefault();

      var mostRecent = Goals.findOne();
      var documentId = mostRecent._id;
      var goal = $('[name="goal"]').val();
      Goals.update(
        { _id: documentId },
        {$set: { dailyGoal: goal }
      });
    },
    'keyup [name=content]': function(e){
      var wordsToCount = $('[name="content"]').val();
      Meteor.call('getWordcount', wordsToCount, function(err, results){
        if(err) console.error(err);
        else    Session.set('wordCountResult', results);
      });
    }
  })
}

// server/app.js

Meteor.publish("posts", function(){
  return Posts.find();
});

Meteor.publish("goals", function(){
  return Goals.find();
});&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Finally, for development purposes, let's kick off our Goals collection with one entry since our code only covers updating the daily goal value. We'll add the following to our startup function:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// server/app.js

if (Goals.find().count() === 0) {
  Goals.insert({
    dailyGoal: 1,
    createdAt: new Date(),
  });
};&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Once we reset the database we'll be able to work with our daily goal. Our test should now be passing.&lt;/p&gt;

&lt;p&gt;Finally we can begin to enforce a minimum word count that matches the daily goal. I'm not creating a new tests because this code is going to cause some older tests to break since they don't factor in a minimum word count before submitting their posts. I'll update the tests once they start breaking.&lt;/p&gt;

&lt;p&gt;In order to disallow the user to post, while still providing some feedback, we can wrap the submit input in an if statement. If there's enough words, then display the submit button... if not, then post the message, "Keep writing!"&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// client/index.html
&amp;lt;form&amp;gt;
  Create a post:
  &amp;lt;input type="text" placeholder="add a title" name="title"&amp;gt;
  &amp;lt;textarea placeholder="write your words here" name="content"&amp;gt;&amp;lt;/textarea&amp;gt;
  {{#if enoughWords}}
    &amp;lt;input type="submit" value="Submit" /&amp;gt;
  {{else}}
    Keep writing!
  {{/if}}
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to execute this logic, we'll add a new helper method, enoughWords:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// model/posts.js

Template.createPost.helpers({
  enoughWords: function(){
    var wordcount = Session.get('wordcount');
    var theGoal = Goals.findOne().dailyGoal;
    return wordcount &gt;= theGoal
  }
});&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;If you were to test this out in the UI, you'll see that everything is working. Unfortunately this one modification wreaks havoc on our tests. The main culprits are the "creating posts" and "deleting posts" blocks. So we'll need to rewrite them in order to handle the new word count limitations on posting.&lt;/p&gt;

&lt;p&gt;I updated the tests with setTimeout functions. I experienced a lot of issues with this part in particular. The way to go when there's so much action and dynamism in the UI is to wrap everything in setTimeout functions to give each block of code time to run and for the UI to update itself.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// tests/mocha/client/client.js

describe("Creating Posts", function(){
  before(function(done){
    $('[name="goal"]').val(1);
    $('[name="goal"]').keyup();
    $('[name="title"]').val('a new post');
    $('[name="content"]').val('a new sample post');
    $('[name="content"]').keyup();
    setTimeout(function(){
      $('[type="submit"]').click();
    }, 500)
    done();
  });
  after(function(done){
    setTimeout(function(){
      $('.title:contains("a new post")')
        .siblings('.deletePost').first().click();
    }, 500);
    done();
  });
  it("creates a post when I fill in the fields", function(){
    Meteor.flush();
    setTimeout(function(){
      chai.assert.equal($(".title:eq(0)").html(), "a new post");
    }, 500);
  });
});

describe("deleting posts", function(){
  before(function(done){
    Posts.insert({
      title: "delete me",
      content: "please delete me",
      createdAt: new Date()
    });
    done();
  });
  after(function(done){
    setTimeout(function(){
      $('.title:contains("delete me")')
        .siblings('.deletePost')
        .first()
        .click();
    }, 500);
    done();
  });
  it("deletes when I tell it to delete", function(){
    Meteor.flush();
    $('.title:contains("delete me")')
      .siblings('.deletePost')
      .first()
      .click();
    setTimeout(function(){
        chai.assert.equal($(".title:eq(0)").html(), "Neutra messenger bag");
    }, 500);
  });
});&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Now that we have these tests passing, we've completed a prototype version of Capote. It doesn't have users, and it still has the autopublish and insecure packages. At least now that we have tests written we can continue development without having to worry so much about whether we're breaking functionality with each update.&lt;/p&gt;

&lt;p&gt;If you want to check out the code from this section, you can grab it from &lt;a href="https://github.com/austinsamsel/capote/tree/part-5"&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Building Capote Meteor &amp; Mocha TDD (Part 4)</title>
    <link rel="alternate" href="http://blog.url.com/blog/building-capote-part-4.html"/>
    <id>http://blog.url.com/blog/building-capote-part-4.html</id>
    <published>2015-11-04T17:00:00-05:00</published>
    <updated>2015-11-05T10:29:39-05:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h1&gt;Building Capote: Meteor &amp;amp; Mocha TDD (Part 4)&lt;/h1&gt;

&lt;p&gt;Last week we set up the functionality for users to create posts and delete them. In this part, we're going to build our word count feature.&lt;/p&gt;

&lt;p&gt;You can grab the code from the last chapter &lt;a href="https://github.com/austinsamsel/capote/tree/part-3"&gt;here&lt;/a&gt;. If you want to review the last post, you can &lt;a href="http://hightopsnyc.com/blog/building-capote-part-3.html"&gt;visit it here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let's make sure there's a word count associated with each post, and that it shows up in the UI. I'll write a quick test based on some of the first ones we wrote. It tests to make sure the first post has a word count of 33 words. I know it will have 33 words because I literally just counted the words in that post.&lt;/p&gt;

&lt;p&gt;You can add this test in the "Posts" section, our first set of tests.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// tests/mocha/client/client.js

...
it("should show a wordcount", function(){
  chai.assert.equal($('.wordcount:eq(0)').html(), "33");
});
...&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;First, let's update our fixtures and give each post a word count.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// tests/mocha/client/client.js

...
Posts.insert({
  title: "Neutra messenger bag",
  content: "Tousled forage trust fund readymade Neutra messenger bag. Drinking vinegar chia Marfa, vegan messenger bag disrupt Wes Anderson try-hard. Small batch scenester raw denim synth cronut cornhole, iPhone try-hard single-origin.",
  createdAt: new Date(2015,0,4),
  wordCount: 33
});
Posts.insert({
  title: "fatback filet mignon",
  content: "Bacon ipsum dolor amet alcatra turkey shank cupim corned beef brisket chuck boudin tri-tip t-bone kevin fatback filet mignon. Short loin tongue short ribs.",
  createdAt: new Date(2015,0,3),
  wordCount: 26
});
Posts.insert({
  title: "know what I'm sayin'",
  content: "You see? It's curious. Ted did figure it out - time travel. And when we get back, we gonna tell everyone. How it's possible, how it's done, what the dangers are. But then why fifty years in the future when the spacecraft encounters a black hole does the computer call it an 'unknown entry event'?",
  createdAt: new Date(2015,0,1),
  wordCount: 54
});
...&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Cool.&lt;/p&gt;

&lt;p&gt;Reset the server &lt;em&gt;meteor reset &amp;amp;&amp;amp; meteor&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Let's make the word count visible in the app. You can add this line in the "post" template at the end.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// client/index.html

&amp;lt;div class="wordcount"&amp;gt;{{wordCount}}&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our test should be passing.&lt;/p&gt;

&lt;p&gt;If you create a new post, there's still no way to calculate or record how many words are in the post. It's time to build that feature. We're going to make use of &lt;a href="https://www.npmjs.com/package/wordcount"&gt;wordcount&lt;/a&gt;, an npm package. It does what you might think it does, it counts the words in a string. In order to use npm packages with Meteor, we'll need to add the meteorhacks:npm package.&lt;/p&gt;

&lt;p&gt;In the command line, run:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;$ meteor add meteorhacks:npm&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Adding this package will automatically create a packages.json file. This is where we'll list our packages, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// packages.json
{
  "wordcount": "1.1.1"
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Its a good idea to restart the meteor server at this point so npm and the new package can be loaded into our meteor app.&lt;/p&gt;

&lt;p&gt;Its important to know that when you use meteorhacks:npm, these packages are only available server side. So we'll set up our word count function in our server code as a method, then call it from the client when we need to make use of it.&lt;/p&gt;

&lt;p&gt;Before we write the code, let's also add one more package:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;$ meteor add check&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;The &lt;a href="https://atmospherejs.com/meteor/check"&gt;check&lt;/a&gt; package helps with security by ensuring your users can only pass through the right types of data. You used to be able to use the audit-argument-checks package for the same purpose. But it seems that the check package has taken over. You can read some more about it &lt;a href="http://docs.meteor.com/#/full/check"&gt;in the documentation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Here we are creating a new method called 'getWordcount' which accepts one argument, words, which will be coming from the client. We check to make sure it is only accepting a string. We also require the wordcount package. Finally, we return our argument after running it through the wordcount function that counts the words in our string.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;//server/app.js

Meteor.methods({
  'getWordcount': function getWordcount(words) {
    check(words, String);
    var wordcount = Meteor.npmRequire('wordcount');
    return wordcount(words);
  }
});&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;To see if this is going to work, we call the method in our server file and watch the command line console for an update.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;//server/app.js

Meteor.call('getWordcount', 'hows it going world?', function(err, results){
  if(err){
    console.error(err);
  }
  else{
    console.log('HEY! it worked, it was ' + results + ' words!');
  }
});&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;The message should be logged in the console and look like: "HEY! it worked, it was 4 words!"&lt;/p&gt;

&lt;p&gt;Now we need a way to record how many words the user is actually typing as they type and once we have that number we can easily save it into the database when the user submits their post.&lt;/p&gt;

&lt;p&gt;We'll write a test to make sure that if a user enters two words into the 'content' section of the post, then it should be reflected that the word count is 2. This is the first post where we need to set a timeout before running our assertion. Apparently there is some minimal lag in updating the session and reflecting that in the UI, so we'll give it half a second to update. Our test is going to look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// tests/mocha/client/client.js

describe("wordcount", function() {
  before(function(done){
    $('[name="content"]').val('a new');
    $('[name="content"]').keyup();
    done();
  });
  it("displays the wordcount when the user types in the form", function(){
    Meteor.flush();
    setTimeout(function(){
      chai.assert.equal($('span.wordcount-num').text(), "2")
    }, 500);
  });
});&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Let's create a new template.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// client/index.html

&amp;lt;template name="wordcount"&amp;gt;
  &amp;lt;div class="wordcount-msg"&amp;gt;
    word count: &amp;lt;span class="wordcount-num"&amp;gt;{{wordcount}}&amp;lt;/span&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And include it in underneath the createPost helper.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// client/index.html

&amp;lt;body&amp;gt;
  {{&amp;gt; createPost}}
  {{&amp;gt; wordcount}} &amp;lt;!-- new helper here --&amp;gt;
  &amp;lt;div class="container"&amp;gt;
    {{#each posts}}
      {{&amp;gt; post}}
    {{/each}}
  &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We're going to add a helper and an onRendered call. The onRendered call will set the word count to zero. This makes sense because this should only be called on render, before anyone's typed in the form. Then the helper gets the wordcount's session value.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;//model/posts.js

Template.wordcount.onRendered(function(){
  Session.set('wordcount', 0);
});
Template.wordcount.helpers({
  wordcount: function(){
    return Session.get('wordcount');
  }
});&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Now we need to set the session value. We will tie this in to the keyup action in the form. I got this idea from &lt;a href="http://meteortips.com/second-meteor-tutorial/managing-todos/"&gt;Meteortips&lt;/a&gt;. Whenever a user presses a key (and lifts up their finger) we can fire an event in Meteor that will send whatever is in the form to our wordcount package to count the words. In the createPost events block, add in:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;//model/posts.js

'keyup [name=content]': function(e){
  var wordsToCount = $('[name="content"]').val();
  Meteor.call('getWordcount', wordsToCount, function(err, results){
    if(err){
      console.error(err);
    }
    else{
      Session.set('wordcount', results);
    }
  });
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; I moved all the content from client/posts.js into model/posts.js -- it didn't make sense to have two posts.js files. The above code gets wrapped by the Meteor.isClient if statement.&lt;/p&gt;

&lt;p&gt;This should put our test in the green.&lt;/p&gt;

&lt;p&gt;We'll also take care of one more detail. In order to start again with a clean slate after submitting a post and clearing the form, we should also programmatically wipe the word count session. If we don't, the session value will remain at the previous word count until we start typing again. We can update this by adding in our createPost events function:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;//model/posts.js

$('[name=title]').val('');
$('[name=content]').val('');
Session.set('wordcount', 0); // clears the session.&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Awesome!!!!&lt;/p&gt;

&lt;p&gt;Next up, we're going to add in a daily goals feature and connect it to the word count so we can set a minimum word count for each post.&lt;/p&gt;

&lt;p&gt;If you want to check out the code from this section, you can grab it from &lt;a href="https://github.com/austinsamsel/capote/tree/part-4"&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Building Capote Meteor &amp; Mocha TDD (Part 3)</title>
    <link rel="alternate" href="http://blog.url.com/blog/building-capote-part-3.html"/>
    <id>http://blog.url.com/blog/building-capote-part-3.html</id>
    <published>2015-10-26T19:58:00-04:00</published>
    <updated>2015-11-04T22:22:54-05:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h1&gt;Building Capote: Meteor &amp;amp; Mocha TDD (Part 3)&lt;/h1&gt;

&lt;p&gt;Welcome to Part 3 !!!&lt;/p&gt;

&lt;p&gt;In last week's post we wrote the tests and code for showing our posts in order and we created timestamps for our posts. You can grab the code from the last chapter &lt;a href="https://github.com/austinsamsel/capote/tree/part-2"&gt;here&lt;/a&gt;. If you want to review the last post, you can &lt;a href="http://hightopsnyc.com/blog/building-capote-part-2.html"&gt;visit it here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this part we are going to add the ability to create posts, delete them. I'm going to sprint through the Meteor creating and deleting posts, but give a little more explanation for the tests that go into this.&lt;/p&gt;

&lt;p&gt;Here's our test for creating posts. We're inputting text into our form fields named title and content, then calling jQuery's click handler, &lt;em&gt;.click();&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Finally we check that the first title is matching our assertion. This type of test is in the BDD style, in the sense that I'm thinking about the user finding the form fields on the page, filling in the values and then pressing submit.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// tests/mocha/client/client.js
…
describe("Creating Posts", function(){
  it("creates a post when I fill in the fields", function(){
    Meteor.flush();
    $('[name="title"]').val('a new post');
    $('[name="content"]').val('a new sample post');
    $('[type="submit"]').click();
    chai.assert.equal($(".title:eq(0)").html(), "a new post");
  });
});
…&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;This test will fail until we add in our code to the client. Let's go ahead and update our templates with the form.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//client/index.html
…
{{&amp;gt; createPost}} &amp;lt;!-- new stuff here: this calls in the new createPost template --&amp;gt;
&amp;lt;div class="container"&amp;gt;
  {{#each posts}}
    {{&amp;gt; post}}
  {{/each}}
&amp;lt;/div&amp;gt;
…
&amp;lt;template name="createPost"&amp;gt;
  &amp;lt;div class="create-post"&amp;gt;
    &amp;lt;form&amp;gt;
      Create a post:
      &amp;lt;input type="text" placeholder="add a title" name="title"&amp;gt;
      &amp;lt;textarea placeholder="write your words here" name="content"&amp;gt;&amp;lt;/textarea&amp;gt;
      &amp;lt;input type="submit" value="Submit" /&amp;gt;
   &amp;lt;/form&amp;gt;
 &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our test will still fail until we allow entries to be inserted to the database.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;//client/posts.js
…
Template.createPost.events({
  'submit form': function(e){
    e.preventDefault();
    var title = $('[name="title"]').val();
    var content = $('[name="content"]').val();

    Posts.insert({
      title: title,
      content: content,
      createdAt: new Date()
    });
    $('[name=title]').val('');
    $('[name=content]').val('');
  }
});
…&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;You'll notice all the tests have gone to green... but only the first time you run them!&lt;/p&gt;

&lt;p&gt;If you check out the Mocha iframe in the Velocity panel, you'll see a mirror version of the app. Every time the tests run it will add in a new post and break our previous tests. That's probably a sign these are some brittle tests. Either we can make them a little more general or automatically flush the database every time we run the tests or we can make use of a before or after block to clean up what we've changed. For now, I'm going to do the latter.&lt;/p&gt;

&lt;p&gt;If we successfully add a new post, then let's delete it after it's been created. You could find the post using jQuery... or just use a method to find and remove the post by its ID. I'm doing the latter here. I think its a nicer way to do the clean up than waiting for the delete feature to be working. And what would happen if we build in the delete feature, but it breaks? We'd have many failing tests instead of just one.&lt;/p&gt;

&lt;p&gt;We'll add this test in the beginning of the "describe" block of "Creating Posts".
&lt;span style="color:#fff"&gt;```&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// tests/mocha/client/client.js
…
after(function(done){
  var latestPost = Posts.findOne({}, {sort: {createdAt: -1}});
  var latestId = latestPost._id
  Meteor.autorun(function(){
    if (latestId){
      Posts.remove(latestId);
      done();
    }
  });
});
…&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Stop the server and run &lt;em&gt;meteor reset &amp;amp;&amp;amp; meteor&lt;/em&gt; in the command line to manually reset the database and mirror database. All tests should be passing.&lt;/p&gt;

&lt;p&gt;We'll follow a similar pattern for deleting posts. First, we'll write our tests. I'm imagining we'll have either a text link or a button next to each post. Either way it can have a css class called &lt;em&gt;.deletePost&lt;/em&gt; which we'll reference from our javascript.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;//tests/mocha/client/client.js
…
describe("deleting posts", function(){
  it("deletes when I tell it to delete", function(){
    Meteor.flush();
    $(".deletePost").first().click();
    chai.assert.equal($(".title:eq(0)").html(), "Neutra messenger bag");
  });
});
…&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;We'll add in the code for deleting posts now.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  //client.index.html
  …
  &amp;lt;div class="content"&amp;gt;{{content}}&amp;lt;/div&amp;gt;
  &amp;lt;!-- we'll add in the delete link right below the content helper --&amp;gt;
  • &amp;lt;a href="#" class="deletePost"&amp;gt;delete&amp;lt;/a&amp;gt;
  …
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A new helper for the content template will allow us delete a post in the database.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// client/posts.js
…
Template.post.events({
  'click .deletePost': function(e){
    e.preventDefault();
    var thisPostId = this._id;
    Posts.remove(thisPostId);
  }
});
…&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Again we'll have some wonky action in our tests. Let's create a post before we delete it, so that all our tests begin with a fresh state. We'll add this code first thing in the describe block for "deleting posts".&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// tests/mocha/client/client.js
…
before(function(done){
  Posts.insert({
    title: "delete me",
    content: "please delete me",
    createdAt: new Date()
  });
  done();
});
&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;You'll probably need to run &lt;em&gt;metor reset &amp;amp;&amp;amp; meteor&lt;/em&gt; again from the command line to clear out the databases. Once you do that all tests should be green.&lt;/p&gt;

&lt;p&gt;If you want to check out the code from this section, you can grab it from &lt;a href="https://github.com/austinsamsel/capote/tree/part-3"&gt;GitHub&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="http://hightopsnyc.com/blog/building-capote-part-4.html"&gt;Continue to Part 4&lt;/a&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Improving User Experience Meteor Reactivity and CSS Animations</title>
    <link rel="alternate" href="http://blog.url.com/blog/improving-ux-with-animations-in-meteor.html"/>
    <id>http://blog.url.com/blog/improving-ux-with-animations-in-meteor.html</id>
    <published>2015-10-18T20:16:00-04:00</published>
    <updated>2015-10-31T11:25:59-04:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h1&gt;Improving User Experience: Meteor Reactivity and CSS Animations&lt;/h1&gt;

&lt;p&gt;&lt;a href="https://nicetrack.meteor.com"&gt;Nice Track&lt;/a&gt; is one of the first apps I created using Meteor. It allows you to privately create topics which you can then rate on a daily basis in order to track your progress, satisfaction, or feelings. You can also add a few notes to each rating. After you've rated your topics some statistics are provided so you can analyze your ratings.&lt;/p&gt;

&lt;p&gt;When I was creating this app, I was mostly interested in improving my skills within the Meteor framework. I didn't put a lot of emphasis on how it looked or felt. As a result, it's basically a prototype and not much more. The looks are mostly derived from &lt;a href="http://semantic-ui.com/"&gt;Semantic UI&lt;/a&gt; (my favorite modular, prototyping library). Now I'd love to make this its own thing. I'll be doing it with small improvements. One thing I want to improve on is the animations and to provide better context to users.&lt;/p&gt;

&lt;p&gt;If you want to checkout the before and after you can:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Before:&lt;/strong&gt;
&lt;a href="https://nicetrack-anims-before.meteor.com"&gt;Live version&lt;/a&gt;
 / &lt;a href="https://github.com/austinsamsel/endless-race/tree/css-animations-before"&gt;GitHub&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;After:&lt;/strong&gt;
&lt;a href="https://nicetrack-anims-after.meteor.com"&gt;Live version&lt;/a&gt;
 / &lt;a href="https://github.com/austinsamsel/endless-race/tree/css-animations-after"&gt;GitHub&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Currently, when a user rates a topic, here's the code I used to slide up the item and fade it out of view. It fires once a rating is successfully submitted. It works and looks fine, however when a user goes to another page and comes back, all the animations are undone and the DOM resets itself showing posts that were just recently rated. This was fine for prototyping and executing an effect, but as I improve the app, this is one thing I want to take care of. I'd like to encourage users to rate their topics once a day.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// client/templates/ratings/rating_submit.js

this.$(e.target).closest('.topicItem').fadeTo('fast', 0.00, function() {
  $(this).slideUp("fast", function(){
    $(this).remove();
    //$(this).addClass('hideIt');

    Meteor.setInterval(function(){
      Session.clear('hideIt')
    }, 5 * 1000 * 6);
  });
});&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;This code resulted in an effect like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" data-src="/images/blog/animation-before.gif" alt="ui before"&gt;&lt;/p&gt;

&lt;p&gt;In order to bring the animation in line to the data... I'm using this logic. If a topic has been rated within the last 6 hours, its form should be hidden. So I created a helper that looks like this:
`&lt;pre&gt;&lt;code class="language-javascript"&gt;// client/templates/topics/topic_item.js
Template.topicItemRate.helpers({
  hideRecent: function(parentContext){
    var timeRange = moment().subtract(12, 'hours')._d;
    if (this.lastRating &gt; timeRange) {
      return "hideThis";
    }
  }
});&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;I make use of &lt;a href="http://momentjs.com/"&gt;Moment JS&lt;/a&gt; to create a variable for the time set at 6 hours ago. Then I use that timeframe to check if the last rating happened within the last 6 hours. If it did, then I'll fade out that topic's rating form and remove it from the UI.&lt;/p&gt;

&lt;p&gt;The template looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// client/templates/topics/topic_item.js

&amp;lt;template name="topicItemRate"&amp;gt;
  {{#if recentlyRated}}
  {{else}}
    &amp;lt;div class="ui segment list topicItem {{hideRecent}}"&amp;gt; &amp;lt;!-- added in the {{minRecent}} helper here --&amp;gt;
      &amp;lt;div class="item"&amp;gt;
        &amp;lt;div class="header"&amp;gt;&amp;lt;h3&amp;gt;{{title}} &amp;lt;/h3&amp;gt;&amp;lt;/div&amp;gt;
        {{&amp;gt; ratingSubmit}}
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  {{/if}}
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the {{minRecent}} helper is active, it adds the class, "hideThis" which includes this CSS:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-css"&gt;// client/stylesheets/style.scss

@keyframes fadeOut {
  0% {
    max-height: 500px;
    opacity: 1;
  }
  39% {
    max-height: 300px;
    opacity: .80;
  }
  78.75% {
    max-height: 50px;
    opacity: .3;
  }
  99.999999% {
    max-height: 0px;
    opacity: 0;
    position:relative;
    z-index:1;
    padding: 0 1em; /* makes animation smoother */
  }
  100%{
    position:absolute;
    top:-9999999px;
    left:-9999999px;
    z-index:-999999999;
  }
}
.topicItem {
  opacity:1.0;
  max-height:10000px;
  overflow:hidden;
  transition:translateY 0.5s linear;
  z-index:1;
  position:relative;
  transform:translateY(0)
}
.topicItem.hideThis{
  animation: fadeOut 500ms linear 0s 1 alternate forwards;
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Our new animation looks like this:&lt;/p&gt;

&lt;p&gt;&lt;img src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" data-src="/images/blog/animation-after.gif" alt="ui afterwards"&gt;&lt;/p&gt;

&lt;p&gt;It's basically the same look, except that even if a user refreshes the page or navigates away and comes back, topics that have already been rated within the past 12 hours will not be hidden.&lt;/p&gt;

&lt;p&gt;In the same way many apps use notifications, I'll implement a counter for how many items are ready to be rated. I want to compel people to check out the Ratings page since the activity on there drives the app. Also, the number of topics that need ratings may change from time to time, so it'd be good to give the user an idea of what remains unrated even while elsewhere in the app.&lt;/p&gt;

&lt;p&gt;I created a todoCount helper which counts how many topics have not been rated within the past 6 hours.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// client/templates/includes/header.js

todoCount: function(){
    var timeRange = moment().subtract(12, 'hours')._d;
    var topicsCount = Topics.find({ 'lastRating' : { $lte: timeRange } });

    return topicsCount.count();
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Then the corresponding helper in the header template:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// client/templates/includes/header.html
...
&amp;lt;a class="{{activeRouteClass 'home' 'toRateTopics'}} item" href="{{pathFor 'toRateTopics'}}"&amp;gt;
    &amp;lt;i class="checkmark icon"&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;span class="menu-title"&amp;gt;Rate &amp;lt;span class='todo'&amp;gt;{{todoCount}}&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;!-- added the {{todoCount}} helper here --&amp;gt;
&amp;lt;/a&amp;gt;
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And I'll give it some nice CSS styling so it fits in more as a "notification count" which will appear in a little pink bubble.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-css"&gt;// client/stylesheets/style.scss

span.todo{
  background: deeppink;
  position: relative;
  color: #fff;
  font-weight: bold;
  border-radius: 5px;
  font-size: 10px;
  padding: 2px 5px 2px 6px;
  text-align: center;
  vertical-align: 3px;
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;While its nice to have an animation that hides each topic item, it'd be nice if it didn't run the animation when coming to the ratings page from another page in the app. I'd really like for it to only start an animation after the user makes a rating.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;//client/topics/topic_item.js
Template.topicItemRate.onRendered (function() {
  $('.hideThis').remove();
});&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;This will remove any rating cards that have a .hideThis class attached once the items have rendered. This is a quick and easy way of skipping the loading animation when we don't really need it.&lt;/p&gt;

&lt;p&gt;I think these updates will make using Nice Track a little bit more enjoyable and sensible. If you have any suggestions for improvements please let me know!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Building Capote Meteor &amp; Mocha TDD (Part2)</title>
    <link rel="alternate" href="http://blog.url.com/blog/building-capote-part-2.html"/>
    <id>http://blog.url.com/blog/building-capote-part-2.html</id>
    <published>2015-10-10T18:08:00-04:00</published>
    <updated>2015-10-31T11:26:01-04:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h1&gt;Building Capote: Meteor &amp;amp; Mocha TDD (Part 2)&lt;/h1&gt;

&lt;p&gt;In the last post, we set up our app, fixtures, and got our first test to pass. You can grab the code from the last chapter &lt;a href="https://github.com/austinsamsel/capote/tree/part-1"&gt;here&lt;/a&gt;. If you want to review the last post, you can &lt;a href="http://hightopsnyc.com/blog/building-capote.html"&gt;visit it here&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Testing UI Objects and Sort Order&lt;/h2&gt;

&lt;p&gt;It's time to actually show our posts in the UI to our users. In the first test, I want to make sure there's at least one post displaying by checking if the css class that's associated with the post gets printed to the page. Then I'll know there's a post on the page, no matter the content of the post. Then I want to test the order of the posts so that the most recent posts show up first in the list.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// tests/mocha/client/client.js

if (!(typeof MochaWeb === 'undefined')){
  MochaWeb.testOnly(function(){

    describe("Posts", function(){
      it("shows a post", function(){
        Meteor.flush();
        chai.assert.typeOf($(".title:eq(0)"), 'object');
      })
      it("should show my latest post, first.", function(){
        Meteor.flush();
        chai.assert.equal($(".title:eq(0)").html(), "Neutra messenger bag");
      });
    });

  });
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;After the tests, we'll get to writing the actual code. First we'll create a subscription so our template can find the posts in the database. We don't need to create a publication since we still have the autopublish package installed by default (and we'd be sure to remove it if this app was going into production). We also set up our templates to display the posts.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// client/posts.js
if (Meteor.isClient) {
  Template.body.helpers({
    posts: function () {
      return Posts.find({}, {sort: {createdAt: -1}});
    }
  });
}&lt;/code&gt;&lt;/pre&gt;


&lt;pre&gt;&lt;code&gt;// client/index.html
&amp;lt;head&amp;gt;
  &amp;lt;meta name="viewport" content="width=device-width, initial-scale=1" /&amp;gt;
  &amp;lt;title&amp;gt;Capote - track your words per day&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
  &amp;lt;div class="container"&amp;gt;
    {{#each posts}}
      {{&amp;gt; post}}
    {{/each}}
  &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;template name="post"&amp;gt;
  &amp;lt;div class="title"&amp;gt;{{title}}&amp;lt;/div&amp;gt;
  &amp;lt;div class="content"&amp;gt;{{content}}&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Testing Timestamps&lt;/h2&gt;

&lt;p&gt;Before we can think about measuring the daily word count streak, we need to include a timestamp with each post. The following is a test to check for that.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// tests/mocha/client/client
...
  it("should show a clean timestamp", function(){
    chai.assert.equal($(".timestamp:eq(1)").html(), "01-03-2015");
  });
...&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;We'll update our fixtures by adding a date/time for when our posts are created. We'll also include the new field in our templates.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// server/app.js

if (Meteor.isServer) {
  Meteor.startup(function () {
    if (Posts.find().count() === 0) {
      Posts.insert({
        title: "Neutra messenger bag",
        content: "Tousled forage trust fund readymade Neutra messenger bag. Drinking vinegar chia Marfa, vegan messenger bag disrupt Wes Anderson try-hard. Small batch scenester raw denim synth cronut cornhole, iPhone try-hard single-origin.",
        createdAt: new Date(2015,0,4) // new timestamp
      });
      Posts.insert({
        title: "fatback filet mignon",
        content: "Bacon ipsum dolor amet alcatra turkey shank cupim corned beef brisket chuck boudin tri-tip t-bone kevin fatback filet mignon. Short loin tongue short ribs.",
        createdAt: new Date(2015,0,3) // new timestamp
      });
      Posts.insert({
        title: "know what I'm sayin'",
        content: "You see? It's curious. Ted did figure it out - time travel. And when we get back, we gonna tell everyone. How it's possible, how it's done, what the dangers are. But then why fifty years in the future when the spacecraft encounters a black hole does the computer call it an 'unknown entry event'?",
        createdAt: new Date(2015,0,1) // new timestamp
      });
    }
  });
}&lt;/code&gt;&lt;/pre&gt;


&lt;pre&gt;&lt;code&gt;// client/index.html

&amp;lt;template name="post"&amp;gt;
  &amp;lt;!-- our new timestamp below --&amp;gt;
  &amp;lt;div class="timestamp"&amp;gt;{{createdAt}}&amp;lt;/div&amp;gt;
  &amp;lt;div class="title"&amp;gt;{{title}}&amp;lt;/div&amp;gt;
  &amp;lt;div class="content"&amp;gt;{{content}}&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To see whether this passes or fails, we'll manually reset our app by running &lt;em&gt;meteor reset &amp;amp;&amp;amp; meteor&lt;/em&gt; in the command line. Mocha's mirror derives itself from the application your developing, so the fixtures won't reset on their own. The idea is that you wouldn't want to reset the mirror database each time before running tests because it would take too long.&lt;/p&gt;

&lt;p&gt;Our test still fails because, by default, Meteor prints out the full timestamp, like: &lt;em&gt;Sat Jan 03 2015 00:00:00 GMT-0500 (EST)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;We'll need to make use of &lt;a href="http://momentjs.com/"&gt;Moment JS&lt;/a&gt; to parse our timestamps. Run the following in the command line to add the moment package to our app.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;$ meteor add moments:moment&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Then we'll create a helper to parse the timestamp. It takes the default timestamp as an argument. Next we'll update our template with the cleanDate helper, effectively passing in that long default timestamp and returning our clean timestamp.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// client/helper.js
Template.registerHelper('cleanDate', function(date) {
    return moment(date).format('MM-DD-YYYY');
});
&lt;/code&gt;&lt;/pre&gt;


&lt;pre&gt;&lt;code&gt;// client/index.html
&amp;lt;div class="timestamp"&amp;gt;{{cleanDate createdAt}}&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now our tests all pass.&lt;/p&gt;

&lt;h2&gt;Wrapping Up&lt;/h2&gt;

&lt;p&gt;If you have any questions or you want me to break down the steps even further, please let me know. If you want to check out the code for this section, you can grab it from &lt;a href="https://github.com/austinsamsel/capote/tree/part-2"&gt;GitHub&lt;/a&gt;. In the next post we'll write tests for creating and deleting posts.&lt;/p&gt;

&lt;p&gt;&lt;a href="http://hightopsnyc.com/blog/building-capote-part-3.html"&gt;Continue to Part 3&lt;/a&gt;&lt;/p&gt;
</content>
  </entry>
</feed>
